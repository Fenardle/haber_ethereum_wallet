import 'dart:convert';

import 'package:web3dart/credentials.dart';

import './encryption_service.dart';
import './storage_service.dart';
import './mnemonic_service.dart';
import 'package:bip39/bip39.dart' as bip39;
import 'package:bip32/bip32.dart' as bip32;
import 'package:hex/hex.dart';

abstract class KeyPairService {
  Future<void> createAccount(String password);
  Future<void> importAccount(String privateKey, String password);
  Future<void> setCurrentAccount(String publicKey);
  Future<String?> getCurrentAccount();
  Future<String> generatePrivateKeyFromMnemonic(String mnemonic);
  Future<Map<String, dynamic>> getGeneratedKeyPairs();
  Future<Map<String, dynamic>> getImportedKeyPairs();
  Future<List<String>> getPublicKeys();
  String getPublicKey(String privateKey);
  Future<String?> getPrivateKey(String publicKey, String password);
  Future<void> safeStoreKeyPairs(
      String publicKey, String privateKey, String password, bool isImported);
}

class KeyPairServiceImpl implements KeyPairService {
  final StorageService _storageService;
  final EncryptionService _encryptionService;
  final MnemonicService _mnemonicService;

  KeyPairServiceImpl({
    required StorageService storageService,
    required EncryptionService encryptionService,
    required MnemonicService mnemonicService,
  })  : _storageService = storageService,
        _encryptionService = encryptionService,
        _mnemonicService = mnemonicService;

  /// generate private key using BIP39 and BIP32
  @override
  Future<String> generatePrivateKeyFromMnemonic(String mnemonic) async {
    final seed = bip39.mnemonicToSeed(mnemonic);
    final root = bip32.BIP32.fromSeed(seed);

    final accountIndex = (await getGeneratedKeyPairs()).length;

    final path = "m/44'/60'/0'/0/$accountIndex";

    final child = root.derivePath(path);

    final privateKey = HEX.encode(child.privateKey!.toList());

    return privateKey;
  }

  /// generate a private key from mnemonic, get the public key and set it as current account, then safe store key pair
  @override
  Future<void> createAccount(String password) async {
    final mnemonic = (await _mnemonicService.getMnemonic(password)) ??
        (await _mnemonicService.generateMnemonic(password));
    final privateKey = await generatePrivateKeyFromMnemonic(mnemonic);
    final publicKey = getPublicKey(privateKey);
    setCurrentAccount(publicKey);
    await safeStoreKeyPairs(publicKey, privateKey, password, false);
  }

  /// generate key pair from the imported private key, then store the pair
  @override
  Future<void> importAccount(String privateKey, String password) async {
    final publicKey = getPublicKey(privateKey);
    await safeStoreKeyPairs(publicKey, privateKey, password, true);
  }

  /// set current account
  @override
  Future<void> setCurrentAccount(String publicKey) async {
    await _storageService.safeStore('current_account', publicKey);
  }

  /// get current account
  @override
  Future<String?> getCurrentAccount() async {
    String? currentAccount = await _storageService.safeRead('current_account');
    return currentAccount;
  }

  /// get all the key pairs that is generated by mnemonic
  @override
  Future<Map<String, dynamic>> getGeneratedKeyPairs() async {
    final accounts =
        await _storageService.safeRead('generated_key_pairs') ?? '{}';
    return jsonDecode(accounts);
  }

  /// get all the key pairs that is imported by user's private key
  @override
  Future<Map<String, dynamic>> getImportedKeyPairs() async {
    final accounts =
        await _storageService.safeRead('imported_key_pairs') ?? '{}';
    return jsonDecode(accounts);
  }

  /// get all the public keys
  @override
  Future<List<String>> getPublicKeys() async {
    final generatedAccounts = await getGeneratedKeyPairs();
    final importedAccounts = await getImportedKeyPairs();
    return generatedAccounts.keys.toList() + importedAccounts.keys.toList();
  }

  /// get decrypted private key identified by public account
  @override
  Future<String?> getPrivateKey(String publicKey, String password) async {
    final encryptedPrivateKey = (await getGeneratedKeyPairs())[publicKey] ??
        (await getImportedKeyPairs())[publicKey];
    if (encryptedPrivateKey == null) return null;
    final decryptedPrivateKey =
        await _encryptionService.decryptText(encryptedPrivateKey, password);
    return decryptedPrivateKey;
  }

  /// get public key from private key
  @override
  String getPublicKey(String privateKey) {
    return EthPrivateKey.fromHex(privateKey).address.hexEip55;
  }

  /// encrypt the private key and store the key pair
  @override
  Future<void> safeStoreKeyPairs(String publicKey, String privateKey,
      String password, bool isImported) async {
    final encryptedPrivateKey =
        await _encryptionService.encryptText(privateKey, password);

    final keyPairsType =
        isImported ? 'imported_key_pairs' : 'generated_key_pairs';

    var keyPairs =
        jsonDecode(await _storageService.safeRead(keyPairsType) ?? '{}');

    keyPairs[publicKey] = encryptedPrivateKey;

    await _storageService.safeStore(keyPairsType, jsonEncode(keyPairs));
  }
}

final keyPairsService = KeyPairServiceImpl(
    storageService: storageService,
    encryptionService: encryptionService,
    mnemonicService: mnemonicService);
